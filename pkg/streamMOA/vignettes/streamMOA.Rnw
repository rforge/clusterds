\input{head.tex}

%\VignetteIndexEntry{Introduction to streamMOA}


\subsection{Full experimental comparison on static data} \label{examples:full}

This example shows the \pkg{stream} framework being used from start to finish.
It encompasses the creation of data streams, data clusterers, the online
clustering of data points as micro-clusters, and then the comparison of
offline reclustering.

First, we set up the data. 
We extract 1000 data points and
put them in a \code{DSD_Wrapper} to make sure that
we provide both algorithms with exactly the same data.

<<echo=FALSE>>=
set.seed(1000) 
@
<<>>= 
library("stream") 
dsd <- DSD_Wrapper(DSD_Gaussians(k=3, d=2, noise=0.05), n=1000)
dsd
@

Next, we create the four clustering algorithms and cluster the same 
1000 data points with all of them. Note that we have to reset the stream
before we cluster the data points for the next clustering 
algorithm.

<<>>= 
sample <- DSC_Sample(k=50) 
window <- DSC_Window(horizon=50)
dstream <- DSC_DStream(gridsize=0.05, attraction=TRUE)
tNN <- DSC_tNN(r=0.05, noise=0.05, shared_density=TRUE)
@

We will also use two MOA-based algorithms available via \pkg{streamMOA}.

<<>>=
library(streamMOA)
denstream <- DSC_DenStream(epsilon=0.05) 
clustream <- DSC_CluStream(m=50, k=3) 
@

<<>>=
algorithms <- list(sample=sample, window=window, dstream=dstream, tNN=tNN, 
  denstream=denstream, clustream=clustream)
for(a in algorithms) {
  reset_stream(dsd) 
  cluster(a, dsd, 1000)
}

algorithms
@


After the clustering operations, we plot the calculated micro-clusters and the
original data. 

<<microclusters, fig=TRUE, include=FALSE, width=12,height=20>>= 
op <- par(no.readonly = TRUE)
layout(mat=matrix(1:6, ncol=2))
for(a in algorithms) {
  reset_stream(dsd) 
  plot(a, dsd, main=a$description)
}
par(op)
@

\begin{figure} 
\centering
\includegraphics{streamMOA-microclusters}
\caption{Micro-cluster placement for different data stream clustering algorithms} 
\label{figure:microclusters} 
\end{figure}

<<>>=
sapply(algorithms, FUN=function(a) {
  reset_stream(dsd) 
  evaluate(a, dsd, measure=c("purity", "SSQ"))
})
@


<<>>=
sample_km <- DSC_Kmeans(k=3, description="Sample + weighted k-means")
recluster(sample_km, algorithms$sample)
algorithms$sample <- sample_km 

window_km <- DSC_Kmeans(k=3, description= "Window + weighted k-means")
recluster(window_km, algorithms$window)
algorithms$window <- window_km 
@

<<microclusters, fig=TRUE, include=FALSE, width=8, height=12>>= 
op <- par(no.readonly = TRUE)
layout(mat=matrix(1:6, ncol=2))
for(a in algorithms) {
  reset_stream(dsd) 
  plot(a, dsd, main=a$description, type="both")
}
par(op)
@

<<>>=
sapply(algorithms, FUN=function(a) {
  reset_stream(dsd) 
  evaluate(a, dsd, measure=c("purity", "SSQ", "cRand"), assign="micro", type="macro")
})
@



Next, we will look at macro-clusters. Some algorithms in \pkg{stream} already 
have a reclustering algorithm implemented. For example, 
DenStream uses the reachability defined by DBSCAN. D-Stream
reclusters by merging adjacent dense grids. 
CluStream uses weighted $k$-means.   
All three clustering algorithms 
already produce macro-clusters and can be directly used for analysis.
pling we choose here to use hierarchical reclustering with 
complete-link and cutting the dendrogram to form 3 clusters.

<<>>=  
sample_hc <- DSC_Hierarchical(k=3, method="complete")
recluster(sample_hc, sample)
@

We plot the final clusterings for visual inspection.

<<sample_hc, fig=TRUE, include=FALSE>>= 
reset_stream(dsd) 
plot(sample_hc, dsd, type="macro") 
@

<<denstream_dbscan, fig=TRUE, include=FALSE>>= 
reset_stream(dsd) 
plot(denstream, dsd, type="macro") 
@

<<clustream_kmeans, fig=TRUE, include=FALSE>>= 
reset_stream(dsd) 
plot(clustream, dsd, type="macro") 
@

<<dstream_grids, fig=TRUE, include=FALSE>>= 
reset_stream(dsd) 
plot(dstream, dsd, type="macro") 
@

\begin{figure} \begin{minipage}[b]{.48\linewidth} \centering
\includegraphics{streamMOA-sample_hc} \\(a) Sampling with hierarchical clustering 
\end{minipage}
\begin{minipage}[b]{.48\linewidth} \centering
\includegraphics{streamMOA-denstream_dbscan} \\(b) DenStream with reachability
\end{minipage}

\begin{minipage}[b]{.48\linewidth} \centering
\includegraphics{streamMOA-clustream_kmeans} \\(c) CluStream with weighted $k$-means
\end{minipage}
\begin{minipage}[b]{.48\linewidth} \centering
\includegraphics{streamMOA-dstream_grids} \\(d) D-Stream with merged dense grids
\end{minipage}

\caption{Reclustering results.} 
\label{figure:denstream+clustream+kmeans} 
\end{figure}


The final clusters are shown in Figure \ref{figure:denstream+clustream+kmeans}.
We see that the micro-clusters are for DenStream and CluStream are evenly 
distribution than the random sampling. 
DStream also forms dense grids 
in the most dense areas.
DenStream and DStream suppress noise well, while
CluStream also selects some noise points for micro-clusters.
These plots help with analyzing how micro-clusters
are placed and can help with ``debugging'' problems with micro-cluster
placement in new algorithms.

Finally, we can compare the clusterings using \code{evaluate}.

<<>>= 
sapply(list('Sample+HC'=sample_hc,
  DenStream=denstream, 
  CluStream=clustream, 
  DStream=dstream), 
FUN=function(x){
    reset_stream(dsd)
    evaluate(x, dsd, c("numMicroclusters", "numMacroclusters", 
      "purity", "crand", "SSQ"), type="macro", assign="micro")
})
@

From the evaluation results we see that sampling with hierarchical reclustering and CluStream perform best.  
However, this is only due to the fact that we specified for these algorithms 
the correct number of macro clusters and that the reclustering algorithms
prefer spherical clusters which matches the generating model for the data.
The density-based
algorithms (DenStream and D-Stream) are not ther able to separate the overlapping 
clusters or create small macro-clusters for poorly connected
micro-clusters. 

\subsection{Full experimental comparison on a evolving data stream} \label{examples:full_evolving}



\input{foot.tex}
